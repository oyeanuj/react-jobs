{"version":3,"file":"react-jobs.min.js","sources":["../src/utils.js","../src/withJob.js","../src/createJobContext.js","../src/JobProvider.js"],"sourcesContent":["export function getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component'\n}\n\nexport const isPromise = x =>\n  typeof x === 'object' && typeof x.then === 'function'\n\nexport const propsWithoutInternal = props => {\n  // eslint-disable-next-line no-unused-vars\n  const { jobInitState, onJobProcessed, ...rest } = props\n  return rest\n}\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { getDisplayName, isPromise, propsWithoutInternal } from './utils'\n\nconst validSSRModes = ['resolve', 'defer', 'boundary']\nconst neverWorkAgain = () => false\n\nexport default function withJob(config) {\n  if (typeof config !== 'object') {\n    throw new Error('You must provide a config object to withJob')\n  }\n\n  const {\n    work,\n    LoadingComponent,\n    ErrorComponent,\n    serverMode = 'resolve',\n    shouldWorkAgain = neverWorkAgain,\n    onlyUseWrappedComponent = false,\n  } = config\n\n  if (typeof work !== 'function') {\n    throw new Error('You must provide a work function to withJob')\n  }\n\n  if (validSSRModes.indexOf(serverMode) === -1) {\n    throw new Error('Invalid serverMode provided to asyncComponent')\n  }\n\n  const env = typeof window === 'undefined' ? 'node' : 'browser'\n\n  return function wrapWithJob(WrappedComponent) {\n    let id\n\n    class ComponentWithJob extends Component {\n      static displayName = `WithJob(${getDisplayName(WrappedComponent)})`\n\n      static contextTypes = {\n        jobs: PropTypes.shape({\n          getNextId: PropTypes.func.isRequired,\n          register: PropTypes.func.isRequired,\n          get: PropTypes.func.isRequired,\n          getRehydrate: PropTypes.func.isRequired,\n          removeRehydrate: PropTypes.func.isRequired,\n        }),\n        store: PropTypes.object,\n        intl: PropTypes.object,\n      }\n\n      constructor(props, context) {\n        super(props, context)\n\n        // Each instance needs it's own id as that is how we expect work to\n        // be executed.  It is not shared between element instances.\n        if (context.jobs) {\n          id = context.jobs.getNextId()\n        }\n      }\n\n      // @see react-async-bootstrapper\n      bootstrap() {\n        if (env === 'browser') {\n          // No logic for browser, just continue\n          return true\n        }\n\n        // node\n        return serverMode === 'defer' ? false : this.resolveWork(this.props)\n      }\n\n      componentWillMount() {\n        let result\n\n        if (this.context.jobs) {\n          result =\n            env === 'browser'\n              ? this.context.jobs.getRehydrate(id)\n              : this.context.jobs.get(id)\n        }\n\n        this.setState({\n          data: result ? result.data : null,\n          error: null,\n          completed: result != null,\n        })\n      }\n\n      componentDidMount() {\n        if (!this.state.completed) {\n          this.resolveWork(this.props)\n        }\n\n        if (this.context.jobs && env === 'browser') {\n          this.context.jobs.removeRehydrate(id)\n        }\n      }\n\n      componentWillUnmount() {\n        this.unmounted = true\n      }\n\n      componentWillReceiveProps(nextProps, nextContext) {\n        const { store, intl } = this.context\n        if (\n          shouldWorkAgain(\n            propsWithoutInternal(this.props),\n            propsWithoutInternal(nextProps),\n            this.getJobState(),\n            { store, intl },\n            { store: nextContext.store, intl: nextContext.intl },\n          )\n        ) {\n          this.resolveWork(nextProps)\n        }\n      }\n\n      resolveWork = props => {\n        let workDefinition\n\n        this.setState({ completed: false, data: null, error: null })\n        const { store, intl } = this.context\n\n        try {\n          workDefinition = work(props, { store, intl })\n        } catch (error) {\n          this.setState({ completed: true, error })\n          // Ensures bootstrap stops\n          return false\n        }\n\n        if (isPromise(workDefinition)) {\n          // Asynchronous result.\n          return workDefinition\n            .then(data => {\n              if (this.unmounted) {\n                return undefined\n              }\n              this.setState({ completed: true, data })\n              this.setJobContext(data)\n              // Ensures bootstrap continues\n              return true\n            })\n            .catch(error => {\n              if (this.unmounted) {\n                return undefined\n              }\n              if (env === 'browser') {\n                setTimeout(() => {\n                  if (!this.unmounted) {\n                    this.setState({ completed: true, error })\n                  }\n                }, 16)\n              } else {\n                // node\n                // We will at least log the error so that user isn't completely\n                // unaware of an error occurring.\n                // eslint-disable-next-line no-console\n                console.warn('Failed to resolve job')\n                // eslint-disable-next-line no-console\n                console.warn(error)\n              }\n              // Ensures bootstrap stops\n              return false\n            })\n        }\n\n        // Synchronous result.\n        this.setJobContext(workDefinition)\n\n        this.setState({ completed: true, data: workDefinition, error: null })\n\n        // Ensures bootstrap continues\n        return true\n      }\n\n      setJobContext = data => {\n        if (this.context.jobs) {\n          this.context.jobs.register(id, { data })\n        }\n      }\n\n      getJobState = () => ({\n        completed: this.state.completed,\n        error: this.state.error,\n        data: this.state.data,\n      })\n\n      render() {\n        const { data, error, completed } = this.state\n\n        if (onlyUseWrappedComponent) {\n          return <WrappedComponent {...this.props} jobState={this.state} />\n        }\n\n        if (error) {\n          return ErrorComponent ? (\n            <ErrorComponent {...this.props} error={error} />\n          ) : null\n        }\n\n        if (!completed) {\n          return LoadingComponent ? <LoadingComponent {...this.props} /> : null\n        }\n\n        return <WrappedComponent {...this.props} jobResult={data} />\n      }\n    }\n\n    return ComponentWithJob\n  }\n}\n","export default function createJobContext() {\n  let idPointer = 0\n  const jobs = {}\n  return {\n    getNextId: () => {\n      idPointer += 1\n      return idPointer\n    },\n    resetIds: () => {\n      idPointer = 0\n    },\n    register: (jobID, result) => {\n      jobs[jobID] = result\n    },\n    get: jobID => jobs[jobID],\n    getState: () => ({ jobs }),\n  }\n}\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nimport createJobContext from './createJobContext'\n\nclass JobProvider extends Component {\n  static propTypes = {\n    children: PropTypes.node.isRequired,\n    jobContext: PropTypes.shape({\n      getNextId: PropTypes.func.isRequired,\n      resetIds: PropTypes.func.isRequired,\n      register: PropTypes.func.isRequired,\n      get: PropTypes.func.isRequired,\n      getState: PropTypes.func.isRequired,\n    }),\n    rehydrateState: PropTypes.shape({\n      jobs: PropTypes.object.isRequired,\n    }),\n  }\n\n  static defaultProps = {\n    jobContext: null,\n    rehydrateState: {\n      jobs: {},\n    },\n  }\n\n  static childContextTypes = {\n    jobs: PropTypes.shape({\n      getNextId: PropTypes.func.isRequired,\n      register: PropTypes.func.isRequired,\n      get: PropTypes.func.isRequired,\n      getRehydrate: PropTypes.func.isRequired,\n      removeRehydrate: PropTypes.func.isRequired,\n    }).isRequired,\n  }\n\n  constructor(props, context) {\n    super(props, context)\n\n    // This is a workaround because each element instance of a job needs its\n    // own ids.  So between the bootstrapping and the render we need to reset\n    // the id counter to ensure the ids will match.\n    if (props.jobContext) {\n      props.jobContext.resetIds()\n    }\n  }\n\n  componentWillMount() {\n    this.jobContext = this.props.jobContext || createJobContext()\n    this.rehydrateState = this.props.rehydrateState\n  }\n\n  getChildContext() {\n    return {\n      jobs: {\n        getNextId: this.jobContext.getNextId,\n        register: this.jobContext.register,\n        get: this.jobContext.get,\n        getRehydrate: id => this.rehydrateState.jobs[id],\n        removeRehydrate: id => {\n          delete this.rehydrateState.jobs[id]\n        },\n      },\n    }\n  }\n\n  render() {\n    return React.Children.only(this.props.children)\n  }\n}\n\nexport default JobProvider\n"],"names":["getDisplayName","WrappedComponent","displayName","name","isPromise","x","then","propsWithoutInternal","props","jobInitState","onJobProcessed","validSSRModes","neverWorkAgain","withJob","config","Error","work","LoadingComponent","ErrorComponent","serverMode","shouldWorkAgain","onlyUseWrappedComponent","indexOf","env","window","id","ComponentWithJob","context","jobs","getNextId","this","resolveWork","result","getRehydrate","get","setState","data","state","completed","removeRehydrate","unmounted","nextProps","nextContext","store","intl","getJobState","error","React","jobState","jobResult","Component","contextTypes","PropTypes","shape","func","isRequired","object","workDefinition","_this2","setJobContext","catch","warn","register","createJobContext","idPointer","jobID","JobProvider","jobContext","resetIds","rehydrateState","Children","only","children","propTypes","node","defaultProps","childContextTypes"],"mappings":"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"}